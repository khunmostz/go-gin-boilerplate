package main

import (
	"context"
	"fmt"
	"go-gin-boilerplate/config"
	"go-gin-boilerplate/internal/cache"
	"go-gin-boilerplate/internal/db"
	"go-gin-boilerplate/internal/handler"
	"go-gin-boilerplate/internal/handler/api"
	"go-gin-boilerplate/internal/middleware"
	"go-gin-boilerplate/internal/repository"
	"go-gin-boilerplate/internal/service"
	"go-gin-boilerplate/internal/utils"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	_ "go-gin-boilerplate/docs" // docs is generated by Swag CLI, you have to import it.
)

// @title           GO Gin Boilerplate API
// @version         1.0
// @description     A GO Gin Boilerplate API service
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Enter JWT token in the format: Bearer {your_token_here}

func gracefulShutdown(server *http.Server) {
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	<-quit
	log.Println("Shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v", err)
	}

	log.Println("Server gracefully stopped")
}

func main() {
	// Load configuration
	env := os.Getenv("APP_ENV")
	if env == "" {
		env = "example" // default to development
	}

	appConfig, err := config.LoadConfigFromEnv(env)
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	// Print configuration
	appConfig.PrintConfig()

	_ = cache.InitRedis(&appConfig.Redis)

	var baseRepo db.BaseRepository
	switch appConfig.Database.Type {
	case "postgresql", "postgres":
		baseRepo = db.NewPgsqlRepository(db.InitPgsql(&appConfig.Database))
	case "mongodb", "mongo":
		baseRepo = db.NewMongoRepository(db.InitMongo(&appConfig.Database), appConfig.Database.MongoDB.DBName)
	}

	router := gin.Default()

	// Swagger route
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// HealthCheck endpoint
	// @Summary      Health check
	// @Description  Check if the service is running
	// @Tags         health
	// @Produce      json
	// @Success      200 {object} map[string]string "Service is running"
	// @Router       /health [get]
	router.GET("/api/v1/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	jwt := utils.NewJWT(&appConfig.JWT)

	apiRouter := router.Group("/api/v1")

	// initialize auth router
	authRouter := apiRouter.Group("/auth")
	{
		authSvc := service.NewAuthService(jwt)
		authHandler := handler.NewAuthHandler(authSvc)
		authRouter.POST("/login", authHandler.Login)
	}

	// initialize bar router with auth middleware
	barRouter := apiRouter.Group("/bar")
	barRouter.Use(middleware.AuthMiddleware(jwt))
	{
		barRepo := repository.NewBarRepository(baseRepo, "bar")
		barSvc := service.NewBarService(barRepo)
		barHandler := handler.NewBarHandler(barSvc)
		api.RegisterBarRoutes(barRouter, barHandler)
	}

	// initialize foo router
	fooRouter := apiRouter.Group("/foo")
	{
		fooRepo := repository.NewFooRepository(baseRepo, "foo")
		fooSvc := service.NewFooService(fooRepo)
		fooHandler := handler.NewFooHandler(fooSvc)
		api.RegisterFooRoutes(fooRouter, fooHandler)
	}

	Port := appConfig.Server.Port

	server := &http.Server{
		Addr:    fmt.Sprintf(":%s", Port),
		Handler: router,
	}

	go func() {
		log.Println("Starting server on :8080")
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Failed to start server: %v", err)
		}
	}()

	gracefulShutdown(server)
}
